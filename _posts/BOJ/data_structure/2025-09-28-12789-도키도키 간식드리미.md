---
layout: post
title: "[BOJ] 1269번: 도키도키 간식드리미"
date: 2025-09-28
categories: ["boj", "data_structure"]
tags: ["Silver-4", "stack", ]
---
---
# 12789번: 도키도키 간식드리미 - <img src="https://static.solved.ac/tier_small/8.svg" style="height:20px" /> Silver III
---
<!-- performance -->

<!-- 문제 제출 후 깃허브에 푸시를 했을 때 제출한 코드의 성능이 입력될 공간입니다.-->

<!-- end -->

## 문제
---
[문제 링크](https://boj.kr/12789)

<p>인하대학교 학생회에서는 중간, 기말고사 때마다 시험 공부에 지친 학우들을 위해 간식을 나눠주는 간식 드리미 행사를 실시한다. 승환이는 시험 기간이 될 때마다 간식을 받을 생각에 두근두근 설레서 시험 공부에 집중을 못 한다. 이번 중간고사에서도 역시 승환이는 설레는 가슴을 안고 간식을 받기 위해 미리 공지된 장소에 시간 맞춰 도착했다. 그런데 이게 무슨 날벼락인가! 그 곳에는 이미 모든 학생들이 모여있었고, 승환이는 마지막 번호표를 받게 되었다. 설상가상으로 몇몇 양심에 털이 난 학생들이 새치기를 거듭한 끝에 대기열의 순서마저 엉망이 되고 말았다. 간식을 나눠주고 있던 인규는 학우들의 터져 나오는 불만에 번호표 순서로만 간식을 줄 수 있다고 말했다.&nbsp;</p>

<p>그제야 학생들이 순서대로 줄을 서려고 했지만 공간이 너무 협소해서 마음대로 이동할 수 없었다. 다행히도 대기열의 왼쪽에는 1열로 설 수 있는 공간이 존재하여 이 공간을 잘 이용하면 모두가 순서대로 간식을 받을 수 있을지도 모른다. 자칫 간식을 못 받게 될지도 모른다는 위기감을 느낀 승환이는 자신의 컴퓨터 알고리즘적 지식을 활용해 과연 모든 사람들이 순서대로 간식을 받을 수 있는지 확인하는 프로그램을 만들기로 했다. 만약 불가능 하다면 승환이는 이번 중간고사를 망치게 될 것 이고 가능하다면 힘을 얻어 중간고사를 잘 볼 수 있을지도 모른다.</p>

<p>사람들은 현재 1열로 줄을 서있고, 맨 앞의 사람만 이동이 가능하다. 인규는 번호표 순서대로만 통과할 수 있는 라인을 만들어 두었다. 이 라인과 대기열의 맨 앞 사람 사이에는 한 사람씩 1열이 들어갈 수 있는 공간이 있다. 현재 대기열의 사람들은 이 공간으로 올 수 있지만 반대는 불가능하다. 승환이를 도와 프로그램을 완성하라.</p>

<p>현재 간식 배부 공간을 그림으로 나타내면 다음과 같다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12789/1.png" style="height:169px; width:306px"></p>

<p>위 예제는 다음 그림과 같이 움직였을 때 모두가 순서대로 간식을 받을 수 있다..</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12789/2.png" style="height:119px; width:470px"></p>

## 입력
---
<p>입력의 첫째 줄에는 현재 승환이의 앞에 서 있는 학생들의 수 <em>N</em>(1 ≤ <em>N</em> ≤ 1,000,자연수)이 주어진다.</p>

<p>다음 줄에는 승환이 앞에 서있는 모든 학생들의 번호표(1,2,...,<em>N</em>) 순서가 앞에서부터 뒤 순서로 주어진다.</p>

## 출력
---
<p>승환이가 무사히 간식을 받을 수 있으면 "Nice"(따옴표는 제외)를 출력하고 그렇지 않다면 "Sad"(따옴표는 제외)를 출력한다.</p>

## 문제 풀이
---
#### 문제에서 **왼쪽 라인의 구조**를 보고 '**`Stack`** 구조를 써야겠다'라는 생각이 들었습니다
#### 우선 **`Stack`**의 기본 구조를 구현해줍니다 파이썬에는 내장된 **`list`**가 있지만 그럼에도 한 번 구현해 보았습니다

```py
class stack:
    def __init__(self):
        self.array = []
    
    def add(self, b):
        self.array.append(b)
    
    def last(self):
        if len(self.array) != 0:
            return self.array[-1]
        else:
            return None
     
    def pop(self):
        if len(self.array) != 0:
            self.array.pop()
```
#### 코드 로직은 다음과 같이 진행됩니다
1. 주 라인의 맨 앞 혹은 왼쪽 라인의 맨 뒷 사람이 지나갈 수 있는가
2. 그렇지 않다면 주 라인의 맨 앞 사람을 왼쪽 라인의 뒤로 보낸다
3. 만약 주 라인에 받을 사람이 없고, 왼쪽 라인의 맨 뒷 사람이 받을 수 없으면 **_실패_**
4. 마지막까지 모든 사람이 지나갔다면 **_성공_**

#### 기본변수
```py
n = int(sys.stdin.readline()) # 총 학생수
students = list(map(int, sys.stdin.readline().rstrip().split())) # 두 라인에 있는 학생들의 번호
target = 1          # 지금 간식을 받아야 할 학생 번호
line = stack()      # 보조 대기 공간 (후입선출 구조)
cond = True         # 조건 충족 여부
```
#### 반복문의 종료조건에 해당되고 target 변수의 현재 값에 따라 성공 여부가 정해집니다 
```py
while True:
    # 성공
    if target == n+1:
        break
    # 실패 타겟이 line의 맨 뒤에 없고 주 라인에도 없으므로 실패
    if target != line.last() and target not in students:
        cond = False
        break
```
#### 주 라인의 맨 앞 사람의 번호와 왼쪽 라인의 맨 뒷 사람의 번호 중 지나갈 수 있는 사람이 있으면 보내고 그렇지 않으면 주 라인의 맨 앞사람을 왼쪽 라인의 맨 뒤로 보냅니다
```py
if (len(students) > 0 and students[0] == target) or line.last() == target:
        if len(students) > 0 and students[0] == target:
            students = students[1:]
        else:
            line.pop()
        target += 1
    else:
        line.add(students[0])
        students = students[1:]
```
#### 반복문을 마쳤을 때, **`cond`**의 상태에 따라서 출력값이 달라집니다
```py
if cond:
    sys.stdout.write('Nice')
else:
    sys.stdout.write('Sad')
```
#### 전체 코드 
```py
import sys

class stack:
    def __init__(self):
        self.array = []
    
    def add(self, b):
        self.array.append(b)
    
    def last(self):
        if len(self.array) != 0:
            return self.array[-1]
        else:
            return None
     
    def pop(self):
        if len(self.array) != 0:
            self.array.pop()
    
n = int(sys.stdin.readline())
students = list(map(int, sys.stdin.readline().rstrip().split()))
target = 1
line = stack()

cond = True
while True:
    # 성공적으로 마무리
    if target == n+1:
        break
    if target != line.last() and target not in students:
        cond = False
        break
    # 본 라인 혹은 임시 라인에 값이 있으면
    if (len(students) > 0 and students[0] == target) or line.last() == target:
        if len(students) > 0 and students[0] == target:
            students = students[1:]
        else:
            line.pop()
        target += 1
    else:
        line.add(students[0])
        students = students[1:]
    
if cond:
    sys.stdout.write('Nice')
else:
    sys.stdout.write('Sad')
```